<?php
include('Product.php');

$car = new Product(1, 'audi-S8', 35000, 'sport-cars', 123, 'audi');
$car->showProductInfo();

$badCar = new ProductReturnToVendor(125, 'gazel-bychok', 10000, 'commercial-trucks',
  'g54', 'GAZ', 'brokenEngine', 'dec-28-2018', '1200km');
$badCar->showProductInfo();

// Задание 5
class A {
  public function foo() {
    static $x = 0;
    echo ++$x;
  }
}
$a1 = new A();
$a2 = new A();
$a1->foo(); // выведет  1, так как префиксный инкремент возвращает модифицированное значение, x у всех экземпляров
// класса = 1, так как у нас статическая переменная - она имеет везде одинаковое значение. Дальше
// - аналогичная логика
$a2->foo(); // выведет 2
$a1->foo(); // выведет 3
$a2->foo(); // выведет 4

// Задание 6

// класс А такой же как и выше. Не копирую его и переда выводом echo убираю, если не убрать, то вывод будет 5,1,6,2

class B extends A {
}
$a1 = new A(); // static класса A связан со своими сущностями и не будет влиять на B. B, хоть и наследник A, но это уже
              // другая ветка, создающая другие сущности. И при наследовании, значение переменной x устанавливается в ноль
$b1 = new B(); // static класса B связан со своими экземплярами
$a1->foo(); // выведет 1
$b1->foo(); // выведет 1
$a1->foo(); // выведет 2
$b1->foo(); // выведет 2

// задание 7

//Если конструктор класса не принимает никаких аргументов, то скобки можно опустить, но их наличие - правило хорошего
//тона. Результат задание 7 не будет отличаться от результата задания 6.

/**
 * Created by PhpStorm.
 * User: Alex1
 * Date: 28.12.2018
 * Time: 9:23
 */